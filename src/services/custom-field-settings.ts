/*
 * Custom Field Settings Service
 *
 * This service handles CRUD operations for custom field settings.
 *
 * IMPORTANT: Field ID Management
 * - Custom field IDs are generated by the backend, NOT the frontend
 * - Use createTempCustomField() for UI purposes with temporary IDs (prefixed with 'temp_')
 * - Use createNewCustomField() to get the data structure for new fields to send to API
 * - Temporary fields should be conv    // Process groups
    const groupsMap = new Map<string, FieldGroup>();
    Object.entries(customGroupData).forEach(([, apiGroupField]) => {
        const groupField = apiGroupField as ApiGroupField;
        const groupName = groupField.groupName;

        if (!groupsMap.has(groupName)) {
            groupsMap.set(groupName, {
                id: groupName,
                name: groupName,
                fields: [],
                order: 0, // Will be updated based on fields
            });
        }

        const group = groupsMap.get(groupName)!;
        const mappedGroupField = mapApiGroupFieldToGroupField(groupField);
        mappedGroupField.required = compulsoryCustomFields.includes(groupField.customFieldId);mField before API submission
 * - The backend will assign proper IDs and return the complete field objects
 *
 * Workflow for new fields:
 * 1. UI creates temporary field with createTempCustomField()
 * 2. User edits field in UI (temporary ID preserved)
 * 3. On save, convert to NewCustomField with tempFieldToNewField()
 * 4. Send NewCustomField to API for creation
 * 5. API returns created field with proper backend-assigned ID
 * 6. Update UI state with the returned field data
 */

import authenticatedAxiosInstance from '@/lib/auth/axiosInstance';
import { getInstituteId } from '@/constants/helper';
import { GET_INSITITUTE_SETTINGS, UPDATE_CUSTOM_FIELD_SETTINGS } from '@/constants/urls';

const CUSTOM_FIELD_SETTINGS_KEY = 'CUSTOM_FIELD_SETTING';
const LOCALSTORAGE_KEY = 'custom-field-settings-cache';
const CACHE_EXPIRY_HOURS = 24; // Cache expires after 24 hours

// API Response Types (what we get from GET_INSITITUTE_SETTINGS)
export interface ApiCustomField {
    id: string;
    customFieldId: string;
    instituteId: string;
    groupName: string | null;
    fieldName: string;
    fieldType: 'text' | 'number' | 'dropdown';
    individualOrder: number;
    groupInternalOrder: number | null;
    canBeDeleted: boolean;
    canBeEdited: boolean;
    canBeRenamed: boolean;
    locations: string[];
    status: string;
    options?: string[];
}

export interface ApiGroupField {
    id: string;
    customFieldId: string;
    instituteId: string;
    groupName: string;
    fieldName: string;
    fieldType: string;
    individualOrder: number;
    groupInternalOrder: number;
    canBeDeleted: boolean;
    canBeEdited: boolean;
    canBeRenamed: boolean;
    locations: string[];
    status: string;
}

export interface ApiCustomFieldResponse {
    key: string;
    name: string;
    data: {
        data: {
            groupNames: string[] | null;
            customFieldsNames: string[];
            currentCustomFieldsAndGroups: ApiCustomField[];
            customGroup: Record<string, ApiGroupField>;
            compulsoryCustomFields: string[];
            fixedCustomFields: string[];
            allCustomFields: string[];
            fixedFieldRenameDtos: Array<{
                key: string;
                defaultValue: string;
                customValue: string;
                order: number;
                visibility: boolean;
            }>;
            customFieldLocations: string[];
        };
    };
}

// API Request Types (what we send to UPDATE_CUSTOM_FIELD_SETTINGS)
export interface ApiCustomFieldRequest {
    currentCustomFieldsAndGroups: ApiCustomField[];
    customGroup: Record<string, ApiGroupField>;
    customFieldsNames: string[];
    compulsoryCustomFields: string[];
    fixedCustomFields: string[];
    allCustomFields: string[];
    customFieldLocations: string[];
    groupNames?: string[];
}

// UI Types (for our components)
export interface FieldVisibility {
    learnersList: boolean;
    enrollRequestList: boolean;
    inviteList: boolean;
    assessmentRegistration: boolean;
    liveSessionRegistration: boolean;
    learnerProfile: boolean;
}

export interface CustomField {
    id: string; // customFieldId from API
    name: string;
    type: 'text' | 'dropdown' | 'number';
    options?: string[];
    visibility: FieldVisibility;
    required: boolean;
    canBeDeleted: boolean;
    canBeEdited: boolean;
    canBeRenamed: boolean;
    order: number;
}

// Type for creating new custom fields (without ID - backend will assign)
export interface NewCustomField {
    name: string;
    type: 'text' | 'dropdown' | 'number';
    options?: string[];
    visibility: FieldVisibility;
    required: boolean;
    order?: number;
}

export interface FixedField {
    id: string; // customFieldId from API
    name: string;
    visibility: FieldVisibility;
    required: boolean;
    canBeDeleted: boolean;
    canBeEdited: boolean;
    canBeRenamed: boolean;
    order: number;
}

export interface FieldGroup {
    id: string;
    name: string;
    fields: GroupField[];
    order: number;
}

export interface GroupField {
    id: string; // customFieldId from API
    name: string;
    type: 'text' | 'dropdown' | 'number';
    options?: string[];
    visibility: FieldVisibility;
    required: boolean;
    canBeDeleted: boolean;
    canBeEdited: boolean;
    canBeRenamed: boolean;
    order: number;
    groupInternalOrder: number;
}

// Type for creating new group fields (without ID - backend will assign)
export interface NewGroupField {
    name: string;
    type: 'text' | 'dropdown' | 'number';
    options?: string[];
    visibility: FieldVisibility;
    required: boolean;
    groupInternalOrder: number;
}

export interface CustomFieldSettingsData {
    fixedFields: FixedField[];
    instituteFields: CustomField[];
    customFields: CustomField[];
    fieldGroups: FieldGroup[];
    lastUpdated?: string;
    version?: number;
}

interface CachedCustomFieldSettings {
    data: CustomFieldSettingsData;
    timestamp: number;
    instituteId: string;
}

// Location mapping dictionary
const LOCATION_TO_VISIBILITY_MAP: Record<string, keyof FieldVisibility> = {
    "Learner's List": 'learnersList',
    'Enroll Request List': 'enrollRequestList',
    'Invite List': 'inviteList',
    'Assessment Registration Form': 'assessmentRegistration',
    'Live Session Registration Form': 'liveSessionRegistration',
    'Learner Profile': 'learnerProfile',
};

const VISIBILITY_TO_LOCATION_MAP: Record<keyof FieldVisibility, string> = {
    learnersList: "Learner's List",
    enrollRequestList: 'Enroll Request List',
    inviteList: 'Invite List',
    assessmentRegistration: 'Assessment Registration Form',
    liveSessionRegistration: 'Live Session Registration Form',
    learnerProfile: 'Learner Profile',
};

// System field identifiers (fieldName from API)
const SYSTEM_FIELD_NAMES = ['name', 'email', 'username', 'password', 'batch', 'phone'];

// Mapping Functions

/**
 * Convert API locations array to UI visibility object
 */
const mapLocationsToVisibility = (locations: string[]): FieldVisibility => {
    const visibility: FieldVisibility = {
        learnersList: false,
        enrollRequestList: false,
        inviteList: false,
        assessmentRegistration: false,
        liveSessionRegistration: false,
        learnerProfile: false,
    };

    locations.forEach((location) => {
        const visibilityKey = LOCATION_TO_VISIBILITY_MAP[location];
        if (visibilityKey) {
            visibility[visibilityKey] = true;
        }
    });

    return visibility;
};

/**
 * Convert UI visibility object to API locations array
 */
const mapVisibilityToLocations = (visibility: FieldVisibility): string[] => {
    const locations: string[] = [];

    Object.entries(visibility).forEach(([key, value]) => {
        if (value) {
            const location = VISIBILITY_TO_LOCATION_MAP[key as keyof FieldVisibility];
            if (location) {
                locations.push(location);
            }
        }
    });

    return locations;
};

/**
 * Convert API field to UI fixed field
 */
const mapApiFieldToFixedField = (apiField: ApiCustomField): FixedField => {
    return {
        id: apiField.customFieldId,
        name: apiField.fieldName,
        visibility: mapLocationsToVisibility(apiField.locations),
        required: true, // System fields are typically required
        canBeDeleted: apiField.canBeDeleted,
        canBeEdited: apiField.canBeEdited,
        canBeRenamed: apiField.canBeRenamed,
        order: apiField.individualOrder,
    };
};

/**
 * Convert API field to UI custom field
 */
const mapApiFieldToCustomField = (apiField: ApiCustomField): CustomField => {
    return {
        id: apiField.customFieldId,
        name: apiField.fieldName,
        type: apiField.fieldType as 'text' | 'dropdown' | 'number',
        options: apiField.options,
        visibility: mapLocationsToVisibility(apiField.locations),
        required: false, // Will be determined by compulsoryCustomFields
        canBeDeleted: apiField.canBeDeleted,
        canBeEdited: apiField.canBeEdited,
        canBeRenamed: apiField.canBeRenamed,
        order: apiField.individualOrder,
    };
};

/**
 * Convert API group field to UI group field
 */
const mapApiGroupFieldToGroupField = (apiGroupField: ApiGroupField): GroupField => {
    return {
        id: apiGroupField.customFieldId,
        name: apiGroupField.fieldName,
        type: apiGroupField.fieldType as 'text' | 'dropdown' | 'number',
        visibility: mapLocationsToVisibility(apiGroupField.locations),
        required: false, // Will be determined by compulsoryCustomFields
        canBeDeleted: apiGroupField.canBeDeleted,
        canBeEdited: apiGroupField.canBeEdited,
        canBeRenamed: apiGroupField.canBeRenamed,
        order: apiGroupField.individualOrder,
        groupInternalOrder: apiGroupField.groupInternalOrder,
    };
};

/**
 * Convert UI fixed field to API field
 */
const mapFixedFieldToApiField = (fixedField: FixedField, instituteId: string): ApiCustomField => {
    return {
        id: '', // Will be set by API
        customFieldId: fixedField.id,
        instituteId,
        groupName: null,
        fieldName: fixedField.name,
        fieldType: 'text', // Fixed fields are typically text
        individualOrder: fixedField.order,
        groupInternalOrder: null,
        canBeDeleted: fixedField.canBeDeleted,
        canBeEdited: fixedField.canBeEdited,
        canBeRenamed: fixedField.canBeRenamed,
        locations: mapVisibilityToLocations(fixedField.visibility),
        status: 'ACTIVE',
    };
};

/**
 * Convert UI custom field to API field
 */
const mapCustomFieldToApiField = (
    customField: CustomField,
    instituteId: string
): ApiCustomField => {
    return {
        id: '', // Will be set by API
        customFieldId: customField.id,
        instituteId,
        groupName: null,
        fieldName: customField.name,
        fieldType: customField.type,
        individualOrder: customField.order,
        groupInternalOrder: null,
        canBeDeleted: customField.canBeDeleted,
        canBeEdited: customField.canBeEdited,
        canBeRenamed: customField.canBeRenamed,
        locations: mapVisibilityToLocations(customField.visibility),
        status: 'ACTIVE',
        options: customField.options,
    };
};

/**
 * Convert UI group field to API group field
 */
const mapGroupFieldToApiGroupField = (
    groupField: GroupField,
    instituteId: string,
    groupName: string
): ApiGroupField => {
    return {
        id: '', // Will be set by API
        customFieldId: groupField.id,
        instituteId,
        groupName,
        fieldName: groupField.name,
        fieldType: groupField.type,
        individualOrder: groupField.order,
        groupInternalOrder: groupField.groupInternalOrder,
        canBeDeleted: groupField.canBeDeleted,
        canBeEdited: groupField.canBeEdited,
        canBeRenamed: groupField.canBeRenamed,
        locations: mapVisibilityToLocations(groupField.visibility),
        status: 'ACTIVE',
    };
};

/**
 * Convert API response to UI format
 */
const mapApiResponseToUI = (apiResponse: ApiCustomFieldResponse): CustomFieldSettingsData => {
    console.log('üîç [DEBUG] API Response structure:', {
        hasData: !!apiResponse.data,
        hasNestedData: !!apiResponse.data?.data,
        topLevelKeys: apiResponse.data ? Object.keys(apiResponse.data) : [],
        nestedDataKeys: apiResponse.data?.data ? Object.keys(apiResponse.data.data) : [],
        currentCustomFieldsAndGroups: apiResponse.data?.data?.currentCustomFieldsAndGroups,
        allCustomFields: apiResponse.data?.data?.allCustomFields,
    });

    const fixedFields: FixedField[] = [];
    const instituteFields: CustomField[] = [];
    const customFields: CustomField[] = [];
    const fieldGroups: FieldGroup[] = [];

    // CRITICAL FIX: The actual data is nested under apiResponse.data.data
    const actualData = apiResponse.data?.data;

    if (!actualData) {
        console.error('‚ùå [DEBUG] No nested data found in API response');
        return {
            fixedFields,
            instituteFields,
            customFields,
            fieldGroups,
            lastUpdated: new Date().toISOString(),
            version: 1,
        };
    }

    // Safety check: ensure currentCustomFieldsAndGroups exists and is an array
    const fields = actualData.currentCustomFieldsAndGroups || [];
    const fixedCustomFields = actualData.fixedCustomFields || [];
    const compulsoryCustomFields = actualData.compulsoryCustomFields || [];
    const customGroupData = actualData.customGroup || {};

    console.log('üîç [DEBUG] Processing fields:', {
        fieldsCount: fields.length,
        fixedFieldsCount: fixedCustomFields.length,
        compulsoryFieldsCount: compulsoryCustomFields.length,
    });

    // Process individual fields
    fields.forEach((apiField: ApiCustomField) => {
        if (apiField.groupName) {
            // Skip grouped fields here, they'll be processed with groups
            return;
        }

        const isSystemField = SYSTEM_FIELD_NAMES.includes(apiField.fieldName.toLowerCase());
        const isFixedField = fixedCustomFields.includes(apiField.customFieldId);
        const isRequired = compulsoryCustomFields.includes(apiField.customFieldId);

        if (isSystemField || isFixedField) {
            const fixedField = mapApiFieldToFixedField(apiField);
            fixedField.required = isRequired;
            fixedFields.push(fixedField);
        } else {
            const customField = mapApiFieldToCustomField(apiField);
            customField.required = isRequired;

            // Determine if it's institute field or custom field
            // For now, we'll treat all non-system fields as custom fields
            customFields.push(customField);
        }
    });

    // Process groups
    const groupsMap = new Map<string, FieldGroup>();
    Object.entries(customGroupData).forEach(([, apiGroupField]) => {
        const groupField = apiGroupField as ApiGroupField;
        const groupName = groupField.groupName;

        if (!groupsMap.has(groupName)) {
            groupsMap.set(groupName, {
                id: groupName,
                name: groupName,
                fields: [],
                order: 0, // Will be updated based on fields
            });
        }

        const group = groupsMap.get(groupName)!;
        const mappedGroupField = mapApiGroupFieldToGroupField(groupField);
        mappedGroupField.required = compulsoryCustomFields.includes(groupField.customFieldId);

        group.fields.push(mappedGroupField);

        // Update group order to minimum field order
        if (group.order === 0 || mappedGroupField.order < group.order) {
            group.order = mappedGroupField.order;
        }
    });

    fieldGroups.push(...Array.from(groupsMap.values()));

    // Sort fields by order
    fixedFields.sort((a, b) => a.order - b.order);
    customFields.sort((a, b) => a.order - b.order);
    fieldGroups.sort((a, b) => a.order - b.order);
    fieldGroups.forEach((group) => {
        group.fields.sort((a, b) => a.groupInternalOrder - b.groupInternalOrder);
    });

    return {
        fixedFields,
        instituteFields,
        customFields,
        fieldGroups,
        lastUpdated: new Date().toISOString(),
        version: 1,
    };
};

/**
 * Convert UI format to API request
 */
const mapUIToApiRequest = (uiData: CustomFieldSettingsData): ApiCustomFieldRequest => {
    const instituteId = getInstituteId();
    if (!instituteId) {
        throw new Error('Institute ID not found');
    }

    const currentCustomFieldsAndGroups: ApiCustomField[] = [];
    const customGroup: Record<string, ApiGroupField> = {};
    const customFieldsNames: string[] = [];
    const compulsoryCustomFields: string[] = [];
    const fixedCustomFields: string[] = [];
    const allCustomFields: string[] = [];

    console.log('üîç [DEBUG] UI Data being transformed:', {
        fixedFieldsCount: uiData.fixedFields.length,
        customFieldsCount: uiData.customFields.length,
        instituteFieldsCount: uiData.instituteFields.length,
        firstFixedField: uiData.fixedFields[0]
            ? { id: uiData.fixedFields[0].id, name: uiData.fixedFields[0].name }
            : null,
    });

    // Process fixed fields
    uiData.fixedFields.forEach((fixedField) => {
        const apiField = mapFixedFieldToApiField(fixedField, instituteId);
        currentCustomFieldsAndGroups.push(apiField);

        customFieldsNames.push(fixedField.name);
        fixedCustomFields.push(fixedField.id);
        allCustomFields.push(fixedField.id);

        if (fixedField.required) {
            compulsoryCustomFields.push(fixedField.id);
        }
    });

    // Process institute fields
    uiData.instituteFields.forEach((instituteField) => {
        const apiField = mapCustomFieldToApiField(instituteField, instituteId);
        currentCustomFieldsAndGroups.push(apiField);

        allCustomFields.push(instituteField.id);

        if (instituteField.required) {
            compulsoryCustomFields.push(instituteField.id);
        }
    });

    // Process custom fields
    uiData.customFields.forEach((customField) => {
        const apiField = mapCustomFieldToApiField(customField, instituteId);
        currentCustomFieldsAndGroups.push(apiField);

        allCustomFields.push(customField.id);

        if (customField.required) {
            compulsoryCustomFields.push(customField.id);
        }
    });

    // Process field groups
    const groupNames: string[] = [];
    uiData.fieldGroups.forEach((fieldGroup) => {
        groupNames.push(fieldGroup.name);

        fieldGroup.fields.forEach((groupField) => {
            const apiGroupField = mapGroupFieldToApiGroupField(
                groupField,
                instituteId,
                fieldGroup.name
            );
            customGroup[`${fieldGroup.name}_${groupField.id}`] = apiGroupField;

            allCustomFields.push(groupField.id);

            if (groupField.required) {
                compulsoryCustomFields.push(groupField.id);
            }
        });
    });

    const result = {
        currentCustomFieldsAndGroups,
        customGroup,
        customFieldsNames,
        compulsoryCustomFields,
        fixedCustomFields,
        allCustomFields,
        customFieldLocations: Object.values(VISIBILITY_TO_LOCATION_MAP),
        groupNames: groupNames.length > 0 ? groupNames : undefined,
    };

    console.log('üîç [DEBUG] Final API request payload:', {
        allCustomFields: result.allCustomFields,
        customFieldsNames: result.customFieldsNames,
        fixedCustomFields: result.fixedCustomFields,
        compulsoryCustomFields: result.compulsoryCustomFields,
    });

    return result;
};

/**
 * Get cached custom field settings from localStorage
 */
const getCachedSettings = (): CustomFieldSettingsData | null => {
    try {
        const instituteId = getInstituteId();
        if (!instituteId) {
            console.warn('üö® [DEBUG] Cannot get cached settings: Institute ID not found');
            return null;
        }

        const cached = localStorage.getItem(LOCALSTORAGE_KEY);
        if (!cached) {
            console.log('üîç [DEBUG] No cached settings found in localStorage');
            return null;
        }

        console.log('üîç [DEBUG] Found cached settings in localStorage');

        const cachedData: CachedCustomFieldSettings = JSON.parse(cached);

        // Check if cache is for the same institute
        if (cachedData.instituteId !== instituteId) {
            console.warn(
                `üö® [DEBUG] Cache institute ID mismatch: ${cachedData.instituteId} vs ${instituteId}`
            );
            localStorage.removeItem(LOCALSTORAGE_KEY);
            return null;
        }

        // Check if cache has expired
        const now = Date.now();
        const cacheAge = now - cachedData.timestamp;
        const expiryTime = CACHE_EXPIRY_HOURS * 60 * 60 * 1000; // Convert to milliseconds

        console.log('üîç [DEBUG] Cache age check:', {
            cacheAge: `${Math.round(cacheAge / 1000 / 60)} minutes`,
            expiryTime: `${CACHE_EXPIRY_HOURS} hours`,
            isExpired: cacheAge > expiryTime,
        });

        if (cacheAge > expiryTime) {
            console.warn('üö® [DEBUG] Cache expired, removing from localStorage');
            localStorage.removeItem(LOCALSTORAGE_KEY);
            return null;
        }

        console.log('‚úÖ [DEBUG] Using valid cached settings:', {
            fieldsCount: {
                fixedFields: cachedData.data.fixedFields.length,
                customFields: cachedData.data.customFields.length,
                instituteFields: cachedData.data.instituteFields.length,
            },
        });

        return cachedData.data;
    } catch (error) {
        console.error('‚ùå [DEBUG] Error reading cached custom field settings:', error);
        localStorage.removeItem(LOCALSTORAGE_KEY);
        return null;
    }
};

/**
 * Save custom field settings to localStorage cache
 */
const setCachedSettings = (settings: CustomFieldSettingsData): void => {
    try {
        const instituteId = getInstituteId();
        if (!instituteId) {
            console.warn('üö® [DEBUG] Cannot cache settings: Institute ID not found');
            return;
        }

        const cacheData: CachedCustomFieldSettings = {
            data: settings,
            timestamp: Date.now(),
            instituteId,
        };

        console.log('üîç [DEBUG] Caching settings to localStorage:', {
            key: LOCALSTORAGE_KEY,
            instituteId,
            fieldsCount: {
                fixedFields: settings.fixedFields.length,
                customFields: settings.customFields.length,
                instituteFields: settings.instituteFields.length,
            },
        });

        localStorage.setItem(LOCALSTORAGE_KEY, JSON.stringify(cacheData));

        // Verify the cache was written
        const verification = localStorage.getItem(LOCALSTORAGE_KEY);
        if (verification) {
            console.log('‚úÖ [DEBUG] Settings successfully cached to localStorage');
        } else {
            console.error('‚ùå [DEBUG] Failed to write to localStorage - verification failed');
        }
    } catch (error) {
        console.error('‚ùå [DEBUG] Error caching custom field settings:', error);
    }
};

/**
 * Clear cached custom field settings
 */
export const clearCustomFieldSettingsCache = (): void => {
    localStorage.removeItem(LOCALSTORAGE_KEY);
};

/**
 * Get custom field settings synchronously from cache only (no API call)
 * Returns null if no cache is available - forces API call
 */
export const getCustomFieldSettingsFromCache = (): CustomFieldSettingsData | null => {
    const cachedSettings = getCachedSettings();
    return cachedSettings; // No fallback to defaults - must use backend data
};

/**
 * Fetch custom field settings from API and update cache
 */
const fetchCustomFieldSettingsFromAPI = async (): Promise<CustomFieldSettingsData> => {
    try {
        const instituteId = getInstituteId();

        if (!instituteId) {
            throw new Error('Institute ID not found. Please log in again.');
        }

        console.log('üîç [DEBUG] Fetching from API with instituteId:', instituteId);

        const response = await authenticatedAxiosInstance.get<ApiCustomFieldResponse>(
            GET_INSITITUTE_SETTINGS,
            {
                params: {
                    instituteId,
                    settingKey: CUSTOM_FIELD_SETTINGS_KEY,
                },
            }
        );

        console.log('üîç [DEBUG] API Response:', {
            hasData: !!response.data,
            hasSettingsData: !!response.data?.data,
            allCustomFields: response.data?.data?.data?.allCustomFields,
            responseStructure: response.data
                ? JSON.stringify(response.data, null, 2)
                : 'No response data',
        });

        let settings: CustomFieldSettingsData;

        // If we get a successful response with data, map it to UI format
        if (response.data && response.data.data) {
            console.log('üîç [DEBUG] Mapping API response to UI format...');

            // Check if the data has the expected structure
            if (!response.data.data.data?.allCustomFields) {
                console.warn('üö® [DEBUG] API response missing allCustomFields - using empty array');
            }

            settings = mapApiResponseToUI(response.data);
            console.log('üîç [DEBUG] Mapped settings field IDs:', {
                fixedFields: settings.fixedFields.map((f) => ({ id: f.id, name: f.name })),
                customFields: settings.customFields.map((f) => ({ id: f.id, name: f.name })),
                totalFields:
                    settings.fixedFields.length +
                    settings.customFields.length +
                    settings.instituteFields.length,
            });

            // Validate that we actually got some fields
            const totalFields =
                settings.fixedFields.length +
                settings.customFields.length +
                settings.instituteFields.length;
            if (totalFields === 0) {
                console.warn(
                    'üö® [DEBUG] No fields found in API response - this may indicate an issue'
                );
            } else {
                console.log('‚úÖ [DEBUG] Successfully mapped fields, proceeding to cache...');
            }
        } else {
            // If no data found, throw error - we must have backend data
            console.log('üîç [DEBUG] No API data found - cannot proceed without backend data');
            throw new Error('No custom field settings found in backend. Please contact support.');
        }

        // Cache the settings - this is critical for the UI to work
        console.log('üîç [DEBUG] About to cache settings with setCachedSettings...');
        setCachedSettings(settings);
        console.log('‚úÖ [DEBUG] Settings caching attempted');

        return settings;
    } catch (error: unknown) {
        console.error('üö® [DEBUG] Error fetching custom field settings:', error);

        // Check if it's a 510 error (Setting not found) or other error
        const err = error as { response?: { status?: number; data?: { ex?: string } } };
        if (err.response?.status === 510 || err.response?.data?.ex?.includes('Setting not found')) {
            console.log('üîç [DEBUG] Settings not found (510) - backend has no data yet');
            throw new Error(
                'Custom field settings not configured yet. Please contact your administrator to set up field configurations.'
            );
        }

        // For other errors, also throw - no fallback to defaults
        const message = (error as Error)?.message || 'unknown error';
        console.warn('üö® [DEBUG] Error loading custom field settings:', message);

        // IMPORTANT: Don't use defaults if we have a real API error - this causes UUID issues
        // Instead, throw the error so the UI can handle it properly
        throw new Error(`Failed to load custom field settings: ${message}`);
    }
};

/**
 * Get custom field settings - tries cache first, then API if needed
 */
export const getCustomFieldSettings = async (
    forceRefresh = false
): Promise<CustomFieldSettingsData> => {
    // If forcing refresh, skip cache and fetch from API
    if (forceRefresh) {
        return fetchCustomFieldSettingsFromAPI();
    }

    // Try to get from cache first
    const cachedSettings = getCachedSettings();
    if (cachedSettings) {
        return cachedSettings;
    }

    // If no cache, fetch from API
    return fetchCustomFieldSettingsFromAPI();
};

/**
 * Save custom field settings to API and update cache
 */
export const saveCustomFieldSettings = async (
    settings: CustomFieldSettingsData
): Promise<{ success: boolean; message: string }> => {
    try {
        const instituteId = getInstituteId();

        if (!instituteId) {
            throw new Error('Institute ID not found. Please log in again.');
        }

        // Convert UI data to API format
        const apiRequest = mapUIToApiRequest(settings);

        // Determine if this is a create or update operation
        const cachedSettings = getCachedSettings();
        const isPresent = cachedSettings !== null;

        const requestParams: Record<string, string | boolean> = {
            instituteId,
        };

        // Add isPresent param for updates
        if (isPresent) {
            requestParams.isPresent = true;
        }

        await authenticatedAxiosInstance.post(UPDATE_CUSTOM_FIELD_SETTINGS, apiRequest, {
            params: requestParams,
            headers: {
                'Content-Type': 'application/json',
            },
        });

        // Update cache with the saved settings
        const updatedSettings = {
            ...settings,
            lastUpdated: new Date().toISOString(),
            version: (settings.version || 0) + 1,
        };
        setCachedSettings(updatedSettings);

        return {
            success: true,
            message: 'Custom field settings saved successfully',
        };
    } catch (error) {
        console.error('Error saving custom field settings:', error);
        throw error;
    }
};

/**
 * Validate custom field settings data structure
 */
export const validateCustomFieldSettings = (settings: CustomFieldSettingsData): boolean => {
    try {
        // Check if all required properties exist
        if (!settings.fixedFields || !Array.isArray(settings.fixedFields)) return false;
        if (!settings.instituteFields || !Array.isArray(settings.instituteFields)) return false;
        if (!settings.customFields || !Array.isArray(settings.customFields)) return false;
        if (!settings.fieldGroups || !Array.isArray(settings.fieldGroups)) return false;

        // Validate each field has required properties
        const validateField = (field: CustomField | FixedField): boolean => {
            return !!(
                field.id &&
                field.name &&
                field.visibility &&
                typeof field.required === 'boolean' &&
                typeof field.order === 'number'
            );
        };

        const validateGroupField = (field: GroupField): boolean => {
            return !!(
                field.id &&
                field.name &&
                field.visibility &&
                typeof field.required === 'boolean' &&
                typeof field.order === 'number' &&
                typeof field.groupInternalOrder === 'number'
            );
        };

        const allFieldsValid = [
            ...settings.fixedFields,
            ...settings.instituteFields,
            ...settings.customFields,
        ].every(validateField);

        const allGroupFieldsValid = settings.fieldGroups.every((group) =>
            group.fields.every(validateGroupField)
        );

        return allFieldsValid && allGroupFieldsValid;
    } catch (error) {
        console.error('Error validating custom field settings:', error);
        return false;
    }
};

/**
 * Export field configuration for backup/import purposes
 */
export const exportCustomFieldSettings = (settings: CustomFieldSettingsData): string => {
    try {
        return JSON.stringify(settings, null, 2);
    } catch (error) {
        console.error('Error exporting custom field settings:', error);
        throw new Error('Failed to export settings');
    }
};

/**
 * Import field configuration from backup
 */
export const importCustomFieldSettings = (jsonString: string): CustomFieldSettingsData => {
    try {
        const imported = JSON.parse(jsonString) as CustomFieldSettingsData;

        if (!validateCustomFieldSettings(imported)) {
            throw new Error('Invalid settings format');
        }

        return imported;
    } catch (error) {
        console.error('Error importing custom field settings:', error);
        throw new Error('Failed to import settings: Invalid format');
    }
};

/**
 * Create a new custom field template (without ID - backend will assign the ID)
 */
export const createNewCustomField = (
    name: string,
    type: 'text' | 'dropdown' | 'number',
    options?: string[]
): NewCustomField => {
    return {
        name,
        type,
        options: type === 'dropdown' ? options || [] : undefined,
        visibility: {
            learnersList: false,
            enrollRequestList: false,
            inviteList: false,
            assessmentRegistration: false,
            liveSessionRegistration: false,
            learnerProfile: false,
        },
        required: false,
        order: 999, // Will be updated when added to settings
    };
};

/**
 * Create a new field group template (without ID - backend will assign the ID)
 */
export const createNewFieldGroup = (name: string): Omit<FieldGroup, 'id'> => {
    return {
        name,
        fields: [],
        order: 999, // Will be updated when added to settings
    };
};

/**
 * Create a temporary custom field for UI purposes (with temporary ID)
 * This should only be used in the UI before saving to backend
 */
export const createTempCustomField = (
    name: string,
    type: 'text' | 'dropdown' | 'number',
    options?: string[]
): CustomField => {
    return {
        id: `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // Temporary ID
        name,
        type,
        options: type === 'dropdown' ? options || [] : undefined,
        visibility: {
            learnersList: false,
            enrollRequestList: false,
            inviteList: false,
            assessmentRegistration: false,
            liveSessionRegistration: false,
            learnerProfile: false,
        },
        required: false,
        canBeDeleted: true,
        canBeEdited: true,
        canBeRenamed: true,
        order: 999, // Will be updated when added to settings
    };
};

/**
 * Check if a field has a temporary ID (not yet saved to backend)
 */
export const isTempField = (field: CustomField | FixedField | GroupField): boolean => {
    return field.id.startsWith('temp_');
};

/**
 * Convert a temporary field to a new field for API submission
 */
export const tempFieldToNewField = (field: CustomField): NewCustomField => {
    return {
        name: field.name,
        type: field.type,
        options: field.options,
        visibility: field.visibility,
        required: field.required,
        order: field.order,
    };
};

/**
 * Example workflow for creating a new custom field
 * This shows the proper sequence for handling new fields
 */
export const createCustomFieldWorkflow = async (
    name: string,
    type: 'text' | 'dropdown' | 'number',
    options?: string[]
): Promise<CustomField> => {
    // Step 1: Create new field data (no ID)
    const newFieldData = createNewCustomField(name, type, options);

    // Step 2: Send to API to create the field (API will assign ID)
    // TODO: This would be a separate API endpoint like POST /custom-fields
    // const response = await authenticatedAxiosInstance.post('/custom-fields', newFieldData);
    // return response.data; // Returns CustomField with backend-assigned ID

    // For now, we'll simulate the response
    const simulatedBackendResponse: CustomField = {
        id: `backend_${Date.now()}`, // This would come from backend
        ...newFieldData,
        order: newFieldData.order || 999, // Ensure order is defined
        canBeDeleted: true,
        canBeEdited: true,
        canBeRenamed: true,
    };

    return simulatedBackendResponse;
};
